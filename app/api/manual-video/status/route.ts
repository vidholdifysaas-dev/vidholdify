/**
 * Video Job Status API Route
 * 
 * GET /api/manual-video/status?jobId=<uuid>
 * 
 * Returns the current status of a video generation job.
 * Frontend should poll this endpoint every 5-10 seconds.
 * 
 * INPUT:
 * - jobId: string (query param, required) - UUID of the job
 * 
 * OUTPUT:
 * {
 *   success: boolean,
 *   job: {
 *     id: string,
 *     status: VideoJobStatus,
 *     productName: string,
 *     targetLength: number,
 *     referenceImageUrl?: string,  // Generated by Nano Banana
 *     finalVideoUrl?: string,      // Only when DONE
 *     errorMessage?: string,       // Only when FAILED
 *     progress: {
 *       step: string,
 *       percentage: number,
 *       scenesCompleted?: number,
 *       totalScenes?: number
 *     }
 *   },
 *   scenes?: Scene[]  // Optional, detailed scene status
 * }
 */

import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { db } from "@/configs/db";
import { videoJobs, scenes } from "@/configs/schema";
import { eq, and } from "drizzle-orm";
import { getSignedUrlFromS3Url } from "@/configs/s3";

export const runtime = "nodejs";

// Status to progress mapping
const STATUS_PROGRESS: Record<string, { step: string; percentage: number }> = {
    CREATED: { step: "Initializing...", percentage: 5 },
    GENERATING_IMAGE: { step: "Generating reference image...", percentage: 15 },
    IMAGE_READY: { step: "Reference image ready, planning script...", percentage: 25 },
    PLANNED: { step: "Script ready, generating video scenes...", percentage: 30 },
    SCENES_GENERATING: { step: "Generating video scenes with Veo...", percentage: 50 },
    SCENES_READY: { step: "Stitching final video...", percentage: 85 },
    STITCHING: { step: "Finalizing video...", percentage: 95 },
    DONE: { step: "Complete!", percentage: 100 },
    FAILED: { step: "Failed", percentage: 0 },
};

export async function GET(request: NextRequest) {
    try {
        // Authenticate user
        const { userId } = await auth();
        if (!userId) {
            return NextResponse.json(
                { success: false, error: "Unauthorized" },
                { status: 401 }
            );
        }

        // Get job ID from query params
        const { searchParams } = new URL(request.url);
        const jobId = searchParams.get("jobId");

        if (!jobId) {
            return NextResponse.json(
                { success: false, error: "jobId is required" },
                { status: 400 }
            );
        }

        // Fetch the job
        const [job] = await db
            .select()
            .from(videoJobs)
            .where(and(eq(videoJobs.id, jobId), eq(videoJobs.userId, userId)));

        if (!job) {
            return NextResponse.json(
                { success: false, error: "Job not found" },
                { status: 404 }
            );
        }

        // Fetch scenes for this job
        const jobScenes = await db
            .select()
            .from(scenes)
            .where(eq(scenes.videoJobId, jobId))
            .orderBy(scenes.sceneIndex);

        // Calculate scene progress
        const completedScenes = jobScenes.filter((s) => s.veoStatus === "completed").length;
        const totalScenes = job.sceneCount || jobScenes.length || 0;

        // Get base progress from status
        const baseProgress = STATUS_PROGRESS[job.status] || STATUS_PROGRESS.CREATED;

        // Adjust progress based on scene generation
        const progress = { ...baseProgress };
        if (job.status === "SCENES_GENERATING" && totalScenes > 0) {
            const sceneProgress = (completedScenes / totalScenes) * 55; // 30% to 85% range
            progress.percentage = Math.round(30 + sceneProgress);
            progress.step = `Generating scenes (${completedScenes}/${totalScenes})...`;
        }

        // Generate signed URLs if available
        let signedVideoUrl: string | undefined;
        let signedImageUrl: string | undefined;

        if (job.status === "DONE" && job.finalVideoUrl) {
            try {
                signedVideoUrl = await getSignedUrlFromS3Url(job.finalVideoUrl, 3600);
            } catch {
                signedVideoUrl = job.finalVideoUrl;
            }
        }

        if (job.referenceImageUrl) {
            // If it's already a signed URL or external URL, use as-is
            if (job.referenceImageUrl.includes('X-Amz-Signature') ||
                !job.referenceImageUrl.includes('.s3.') ||
                !job.referenceImageUrl.includes('.amazonaws.com')) {
                signedImageUrl = job.referenceImageUrl;
            } else {
                try {
                    signedImageUrl = await getSignedUrlFromS3Url(job.referenceImageUrl, 3600);
                } catch {
                    signedImageUrl = job.referenceImageUrl;
                }
            }
        }

        // Build response
        const response = {
            success: true,
            job: {
                id: job.id,
                status: job.status,
                productName: job.productName,
                productDescription: job.productDescription,
                targetLength: parseInt(job.targetLength),
                platform: job.platform,
                avatarDescription: job.avatarDescription,
                backgroundDescription: job.backgroundDescription,
                referenceImageUrl: signedImageUrl,
                finalVideoUrl: signedVideoUrl,
                fullScript: job.fullScript,
                errorMessage: job.errorMessage,
                failedAt: job.failedAt,
                createdAt: job.createdAt,
                updatedAt: job.updatedAt,
                completedAt: job.completedAt,
                progress: {
                    ...progress,
                    scenesCompleted: completedScenes,
                    totalScenes,
                },
            },
            scenes: jobScenes.map((scene) => ({
                id: scene.id,
                sceneIndex: scene.sceneIndex,
                plannedDuration: scene.plannedDuration,
                generatedDuration: scene.generatedDuration,
                script: scene.script,
                veoStatus: scene.veoStatus,
            })),
        };

        return NextResponse.json(response);
    } catch (error) {
        console.error("[API] Status check error:", error);
        return NextResponse.json(
            {
                success: false,
                error: error instanceof Error ? error.message : "Failed to get job status",
            },
            { status: 500 }
        );
    }
}
